PROJECT REPORT - CollabDocs (Questionnaire Answers)

Note: Where user-specific details were missing, I assumed a single-developer (individual) project led by AnandShadow. I marked assumptions explicitly.

1. General Details

Project title (Confirmed): Cloud-Based Document Collaboration System
Project type: Individual project (assumption: single developer). If this is a group project, change to "Group" and list members.
Number of team members (if group): 1 (AnandShadow) — assumed
Your role(s) in the project: Full-stack developer — design, frontend and backend implementation, AI service wiring, documentation, deployment guides, and project management.

Assumptions: The repo owner is AnandShadow and worked as the primary developer. Update this section if other contributors exist.

2. Project Overview

What problem or challenge does your system aim to solve?
- Reduce friction in collaborative document editing by providing a single platform for real-time editing, version control, AI-assisted grammar and style suggestions, and secure cloud storage with role-based permissions.
- Address lost changes, inconsistent versions, and slow review workflows in distributed teams.

Who are the target users (e.g., students, organizations, teams)?
- Remote teams and distributed project groups (engineering, content, product)
- Small to medium organizations seeking an affordable collaboration tool
- Educational users (students and instructors) for collaborative assignments
- Content creators and editors who need version history and AI assistance

What makes your system different from existing document editors (like Google Docs or Microsoft 365)?
- Modular microservice architecture enabling on-prem or cloud deployment and pluggable AI services.
- Integrated version history with explicit version snapshots and visual diffs (in repo-like style).
- AI-first capabilities (grammar/style checks, summarization, keyword extraction) provided by a separate Python service that can be swapped or enhanced.
- Designed for extensibility (plugin-style AI service, optional offline mode) and role-based granular sharing.

Expected real-world use cases or benefits:
- Cross-functional teams editing specs and tracking versions with rollback.
- Editorial workflows with automated grammar and style suggestions to reduce manual proofreading.
- Class projects where students collaborate and instructors can review versioned submissions.
- Small businesses storing documents securely with share-and-permission controls.

3. Literature Survey / Existing Systems

Which similar platforms or research works did you study?
- Google Docs (real-time collaboration, OT/CRDT research)
- Microsoft 365 / Office Online
- Notion (hybrid document/database, collaboration tooling)
- Zoho Writer
- Research literature on Operational Transform (OT) and Conflict-free Replicated Data Types (CRDTs) for collaborative editing
- Academic works on real-time synchronization, e.g., Ellis & Gibbs (Operational Transform), recent CRDT implementations

What limitations or gaps did you find in them?
- Limited local extensibility for AI services (closed ecosystems)
- In some solutions, version history is coarse or hard to navigate (not git-like)
- Some platforms lack modular server architecture suitable for small organizations to self-host easily
- Closed-source platforms restrict advanced customizations (custom grammar or domain-specific checks)

How does your system improve or innovate beyond those?
- Provides a pluggable AI service in Python that can be trained and extended for domain-specific checks.
- Offers a git-like version history interface with visual diffs and explicit restore operations.
- Designed for easy self-hosting with Firebase-compatible integrations or Docker deployments.

4. Problem Statement and Objectives

Problem statement (2–3 lines):
Distributed teams lose time reconciling document versions, manually proofreading content, and recovering previous states; this project builds a secure cloud-based collaboration system that provides real-time editing, version history with rollback, and AI-assisted content quality improvements to streamline team workflows.

Main objectives (4–6 clear goals):
1. Provide a real-time collaborative rich-text editor that synchronizes changes instantly between multiple users.
2. Implement secure authentication and role-based access control for document sharing (owner/editor/viewer).
3. Store document versions with a searchable history and allow rollback to previous snapshots.
4. Integrate an AI service for grammar, style, summarization, and keyword extraction to reduce manual editing overhead.
5. Ensure secure cloud storage and scalable architecture to support multiple concurrent users.

5. Scope and Limitations

Main capabilities of the system:
- Account registration and authentication (Firebase-based in full implementation)
- Create, edit, delete, and share rich-text documents
- Real-time synchronization via Socket.IO
- Version history with visual diffs and restore
- Basic comments and presence indicators
- File attachments stored in cloud storage (Google Cloud Storage)
- AI endpoints for analysis (grammar, style, summarization) via a separate Flask service (provisioned but optional in demo)

Limitations and future improvements:
- Current demo uses in-memory storage for quick demos; production requires Firestore configuration.
- AI service installation on Windows requires build tools; recommended to deploy AI service on Linux/GCloud for production.
- Conflict resolution uses server-broadcasted updates (basic); for large-scale production, migrating to a CRDT solution would improve offline and multi-edit robustness.
- No production-grade monitoring or autoscaling configuration in the current codebase; add Terraform/Bicep or Cloud Run autoscaling configs later.

6. Requirement Specification

Functional requirements:
- User registration and login
- Create, read, update, delete documents
- Real-time collaborative editing with multiple users
- Document sharing with role-based permissions (owner/editor/viewer)
- Version snapshotting and retrieval
- Visual diff comparison between versions
- AI analysis endpoints (grammar/style/summarize)
- File attachments (upload/download)

Non-functional requirements:
- Performance: sub-second sync for small documents (hundreds–thousands of characters)
- Scalability: support dozens of concurrent editors per document (scale via Socket.IO cluster)
- Security: JWT token verification, HTTPS, role checks, secure storage policies
- Availability: Health checks and basic retry/backoff patterns
- Usability: Responsive UI, clean editor toolbar, intuitive version UI

7. System Design

Architecture:
- Client-server cloud architecture (frontend React client, backend Node.js/Express with Socket.IO, optional AI microservice in Python/Flask)
- Data flow: clients connect to backend via WebSocket (Socket.IO) for live updates and REST for CRUD; backend persists snapshots to Firestore (or local demo store)

Cloud platform used:
- Designed to work with Firebase (Authentication, Firestore, Realtime DB optional) and Google Cloud Storage for files. Production deployment suggested on Google Cloud Run or similar.

Database used:
- Cloud Firestore for documents and metadata (production). Demo uses in-memory Map for fast presentation.

Frontend tech:
- React.js (18.x), React Quill for rich-text, Socket.IO client, Axios for REST calls

Backend tech:
- Node.js (Express) and Socket.IO for real-time sync, Firebase Admin SDK for server-side authentication, Multer for file uploads, Google Cloud Storage library for attachments

AI microservice:
- Python Flask with spaCy, LanguageTool, TextBlob, Gensim; exposed endpoints for grammar, summarize, recommend

APIs/libraries used (high-level):
- Authentication: Firebase Auth (client) + Firebase Admin (server)
- Real-time: Socket.IO
- Editor: Quill.js
- Storage: Google Cloud Storage (GCS)
- Version diff: diff-match-patch / react-diff-viewer
- AI libraries: spaCy, LanguageTool-Python, TextBlob, Gensim

8. Implementation Details

Development and integration approach:
- Frontend components were built in React and organized by feature (Auth, Dashboard, Editor, Version History)
- Backend routes implemented for auth (server validation), documents (CRUD and versions), and ai (proxy to Python service)
- Socket.IO provides join-document, document-change, and leave-document events. Server broadcasts document updates to room subscribers.
- Versions saved as snapshots (Firestone subcollections in production). Version restore replaces latest snapshot with selected content and creates a new snapshot.

Key modules/features:
- Authentication: Firebase handles sign-in/up; backend verifies tokens via Firebase Admin.
- Document Editor: React Quill with handlers for text-change (debounced) to emit deltas and content to server.
- Collaboration Engine: Socket.IO rooms per document; the server relays updates and tracks active users for presence.
- Cloud Storage: Multer on backend for uploads, uploaded to GCS with signed URLs for secure access.
- Version History: Documents/:id/versions endpoint to create, list, and restore versions; frontend shows diffs using react-diff-viewer.

Tools and IDEs used:
- VS Code for development, Git/GitHub for version control, Postman/curl for API testing, Chrome/Edge DevTools for debugging.

Authentication & role-based access:
- Roles are Owner / Editor / Viewer; backend middleware checks Firebase ID token and verifies access before performing actions.

Pseudo-code (server-side Socket.IO event handler):
```
// On join-document
socket.on('join-document', ({documentId, userId}) => {
  socket.join(documentId);
  // keep presence
  io.to(documentId).emit('active-users', getActiveUsers(documentId));
});

// On document-change
socket.on('document-change', ({documentId, content, delta}) => {
  // persist snapshot or debounce-save
  saveTemporary(documentId, content);
  socket.to(documentId).emit('document-update', {content, delta});
});
```

9. Results and Evaluation

Key results/outputs:
- Fully functional demo with backend (demo mode) and frontend demo page (`demo.html`).
- Real-time edit propagation via Socket.IO tested by creating and editing documents.
- Version snapshot endpoints implemented and tested via API.
- AI microservice skeleton implemented (Flask) with endpoints; local installation requires native build tools on Windows.

Performance/testing outcomes:
- Demo shows sub-second propagation on a local machine for small documents.
- Basic automated checks: health endpoint and CRUD API returning expected JSON.
- Manual tests: created document via curl and via UI; both succeeded.

Comparison with existing solutions:
- Provides core real-time collaboration similar to Google Docs for basic use cases but lacks advanced OT/CRDT offline conflict handling. Distinct advantages: modular AI microservice and git-like explicit version history.

Screenshots/placeholders:
- Placeholder: include screenshots of Dashboard, Editor, Version History, and AI suggestions in the final report. I can capture and embed them if you want.

10. Conclusion and Future Work

Final outcomes and learnings:
- Completed a full-stack prototype demonstrating real-time collaboration, document management, and pluggable AI services.
- Learned integration patterns across Node.js, Socket.IO, React, Firebase, and Python NLP tools.

Future enhancements:
- Implement CRDT-based synchronization for robust offline merging and conflict-free editing.
- Full production AI deployment (hosted on Cloud Run) and improved grammar/style models.
- Add collaborative cursors, user highlights, and live typing indicators.
- Add offline support with local queueing and sync on reconnect.
- Implement automated testing and CI/CD pipelines for deploys.

11. References (examples)
- Google Docs internal docs and OT/CRDT papers
- Quill.js documentation
- Socket.IO documentation
- Firebase documentation
- spaCy, LanguageTool, TextBlob, and Gensim docs

---

If you confirm these answers (and the assumption of an individual project), I will:
1) Expand this into a full structured draft suitable for 25–30 pages and save it as a .txt in the report folder.
2) Then generate a 20-page Word (.docx) with the structure: Cover, Declaration, Abstract, Chapters 1–4, Conclusion, and References.

Tell me whether to proceed with expanding to the full draft and to generate the Word document now.
